{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@solid-primitives+utils@4.0.0_solid-js@1.6.6/node_modules/@solid-primitives/utils/dist/index.js", "../../../../../node_modules/.pnpm/@solid-primitives+destructure@0.1.4_solid-js@1.6.6/node_modules/@solid-primitives/destructure/dist/index.js"],
  "sourcesContent": ["import { DEV, getOwner, onCleanup, createSignal, untrack, batch } from 'solid-js';\nimport { isServer as isServer$1 } from 'solid-js/web';\n\n// src/index.ts\nvar noop = () => void 0;\nvar isServer = isServer$1;\nvar isClient = !isServer;\nvar isDev = DEV && isClient;\nvar isProd = !isDev;\nvar ofClass = (v, c) => v instanceof c || v && v.constructor === c;\nfunction isObject(value) {\n  return value !== null && (typeof value === \"object\" || typeof value === \"function\");\n}\nvar compare = (a, b) => a < b ? -1 : a > b ? 1 : 0;\nvar arrayEquals = (a, b) => a === b || a.length === b.length && a.every((e, i) => e === b[i]);\nfunction chain(callbacks) {\n  return (...args) => {\n    for (const callback of callbacks) {\n      if (typeof callback === \"function\")\n        callback(...args);\n    }\n  };\n}\nvar clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nvar access = (v) => typeof v === \"function\" && !v.length ? v() : v;\nvar asArray = (value) => Array.isArray(value) ? value : [value];\nvar accessArray = (list) => list.map((v) => access(v));\nvar withAccess = (value, fn) => {\n  const _value = access(value);\n  typeof _value !== \"undefined\" && _value !== null && fn(_value);\n};\nvar asAccessor = (v) => typeof v === \"function\" ? v : () => v;\nfunction accessWith(valueOrFn, ...args) {\n  return typeof valueOrFn === \"function\" ? valueOrFn(...args) : valueOrFn;\n}\nvar entries = Object.entries;\nvar keys = Object.keys;\nvar onRootCleanup = (fn) => getOwner() ? onCleanup(fn) : fn;\nvar createCallbackStack = () => {\n  let stack = [];\n  const clear = () => stack = [];\n  return {\n    push: (...callbacks) => stack.push(...callbacks),\n    execute(arg0, arg1, arg2, arg3) {\n      stack.forEach((cb) => cb(arg0, arg1, arg2, arg3));\n      clear();\n    },\n    clear\n  };\n};\nfunction createMicrotask(fn) {\n  let calls = 0;\n  let args;\n  return (...a) => {\n    args = a, calls++;\n    queueMicrotask(() => --calls === 0 && fn(...args));\n  };\n}\nfunction createProxy(traps) {\n  return new Proxy(\n    {},\n    {\n      get: (_, k) => traps.get(k),\n      set: (_, k, v) => {\n        var _a;\n        (_a = traps.set) == null ? void 0 : _a.call(traps, k, v);\n        return false;\n      }\n    }\n  );\n}\nfunction createStaticStore(init) {\n  const copy = { ...init };\n  const store = {};\n  const cache = /* @__PURE__ */ new Map();\n  const getValue = (key) => {\n    const saved = cache.get(key);\n    if (saved)\n      return saved[0]();\n    const signal = createSignal(copy[key], {\n      name: typeof key === \"string\" ? key : void 0\n    });\n    cache.set(key, signal);\n    delete copy[key];\n    return signal[0]();\n  };\n  const setValue = (key, value) => {\n    const saved = cache.get(key);\n    if (saved)\n      return saved[1](value);\n    if (key in copy)\n      copy[key] = accessWith(value, [copy[key]]);\n  };\n  for (const key of keys(init)) {\n    store[key] = void 0;\n    Object.defineProperty(store, key, {\n      get: getValue.bind(void 0, key)\n    });\n  }\n  const setter = (a, b) => {\n    if (isObject(a))\n      untrack(() => {\n        batch(() => {\n          for (const [key, value] of entries(accessWith(a, store)))\n            setValue(key, () => value);\n        });\n      });\n    else\n      setValue(a, b);\n    return store;\n  };\n  return [store, setter];\n}\nfunction handleDiffArray(current, prev, handleAdded, handleRemoved) {\n  const currLength = current.length;\n  const prevLength = prev.length;\n  let i = 0;\n  if (!prevLength) {\n    for (; i < currLength; i++)\n      handleAdded(current[i]);\n    return;\n  }\n  if (!currLength) {\n    for (; i < prevLength; i++)\n      handleRemoved(prev[i]);\n    return;\n  }\n  for (; i < prevLength; i++) {\n    if (prev[i] !== current[i])\n      break;\n  }\n  let prevEl;\n  let currEl;\n  prev = prev.slice(i);\n  current = current.slice(i);\n  for (prevEl of prev) {\n    if (!current.includes(prevEl))\n      handleRemoved(prevEl);\n  }\n  for (currEl of current) {\n    if (!prev.includes(currEl))\n      handleAdded(currEl);\n  }\n}\nvar forEachEntry = (obj, fn) => Object.entries(obj).forEach(([key, value]) => fn(key, value));\n\nexport { access, accessArray, accessWith, arrayEquals, asAccessor, asArray, chain, clamp, compare, createCallbackStack, createMicrotask, createProxy, createStaticStore, entries, forEachEntry, handleDiffArray, isClient, isDev, isObject, isProd, isServer, keys, noop, ofClass, onRootCleanup, withAccess };\n", "import { getOwner, createMemo, runWithOwner } from 'solid-js';\nimport { access } from '@solid-primitives/utils';\n\n// src/index.ts\nvar isReactiveObject = (value) => typeof value === \"object\" && value !== null;\nfunction createProxyCache(obj, get) {\n  return new Proxy(\n    {},\n    {\n      get: (target, key) => {\n        if (key === Symbol.iterator || key === \"length\")\n          return Reflect.get(obj, key);\n        const saved = Reflect.get(target, key);\n        if (saved)\n          return saved;\n        const value = get(key);\n        Reflect.set(target, key, value);\n        return value;\n      },\n      set: () => false\n    }\n  );\n}\nfunction destructure(source, options) {\n  const config = options ?? {};\n  const memo = config.memo ?? typeof source === \"function\";\n  const getter = typeof source === \"function\" ? (key) => () => source()[key] : (key) => () => source[key];\n  const obj = access(source);\n  if (config.lazy) {\n    const owner = getOwner();\n    return createProxyCache(obj, (key) => {\n      const calc = getter(key);\n      if (config.deep && isReactiveObject(obj[key]))\n        return runWithOwner(owner, () => destructure(calc, { ...config, memo }));\n      return memo ? runWithOwner(owner, () => createMemo(calc, void 0, options)) : calc;\n    });\n  }\n  const result = Array.isArray(obj) ? [] : {};\n  for (const [key, value] of Object.entries(obj)) {\n    const calc = getter(key);\n    if (config.deep && isReactiveObject(value))\n      result[key] = destructure(calc, { ...config, memo });\n    else\n      result[key] = memo ? createMemo(calc, void 0, options) : calc;\n  }\n  return result;\n}\n\nexport { destructure };\n"],
  "mappings": ";;;;;;;;;AAwBA,IAAI,SAAS,CAAC,MAAM,OAAO,MAAM,cAAc,CAAC,EAAE,SAAS,EAAE,IAAI;;;ACpBjE,IAAI,mBAAmB,CAAC,UAAU,OAAO,UAAU,YAAY,UAAU;AACzE,SAAS,iBAAiB,KAAK,KAAK;AAClC,SAAO,IAAI;AAAA,IACT,CAAC;AAAA,IACD;AAAA,MACE,KAAK,CAAC,QAAQ,QAAQ;AACpB,YAAI,QAAQ,OAAO,YAAY,QAAQ;AACrC,iBAAO,QAAQ,IAAI,KAAK,GAAG;AAC7B,cAAM,QAAQ,QAAQ,IAAI,QAAQ,GAAG;AACrC,YAAI;AACF,iBAAO;AACT,cAAM,QAAQ,IAAI,GAAG;AACrB,gBAAQ,IAAI,QAAQ,KAAK,KAAK;AAC9B,eAAO;AAAA,MACT;AAAA,MACA,KAAK,MAAM;AAAA,IACb;AAAA,EACF;AACF;AACA,SAAS,YAAY,QAAQ,SAAS;AAvBtC;AAwBE,QAAM,SAAS,4BAAW,CAAC;AAC3B,QAAM,QAAO,YAAO,SAAP,YAAe,OAAO,WAAW;AAC9C,QAAM,SAAS,OAAO,WAAW,aAAa,CAAC,QAAQ,MAAM,OAAO,EAAE,OAAO,CAAC,QAAQ,MAAM,OAAO;AACnG,QAAM,MAAM,OAAO,MAAM;AACzB,MAAI,OAAO,MAAM;AACf,UAAM,QAAQ,SAAS;AACvB,WAAO,iBAAiB,KAAK,CAAC,QAAQ;AACpC,YAAM,OAAO,OAAO,GAAG;AACvB,UAAI,OAAO,QAAQ,iBAAiB,IAAI,IAAI;AAC1C,eAAO,aAAa,OAAO,MAAM,YAAY,MAAM,EAAE,GAAG,QAAQ,KAAK,CAAC,CAAC;AACzE,aAAO,OAAO,aAAa,OAAO,MAAM,WAAW,MAAM,QAAQ,OAAO,CAAC,IAAI;AAAA,IAC/E,CAAC;AAAA,EACH;AACA,QAAM,SAAS,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC;AAC1C,aAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,GAAG,GAAG;AAC9C,UAAM,OAAO,OAAO,GAAG;AACvB,QAAI,OAAO,QAAQ,iBAAiB,KAAK;AACvC,aAAO,OAAO,YAAY,MAAM,EAAE,GAAG,QAAQ,KAAK,CAAC;AAAA;AAEnD,aAAO,OAAO,OAAO,WAAW,MAAM,QAAQ,OAAO,IAAI;AAAA,EAC7D;AACA,SAAO;AACT;",
  "names": []
}
